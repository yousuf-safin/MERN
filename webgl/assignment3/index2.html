<!DOCTYPE html>
<html>
<title>Assignment 3: Hexagonal Prism</title>
<canvas id="webglcanvas" width="600" height="600"></canvas>
<body>
    

<script>
    // WebGL Context Setup
    const canvas = document.getElementById('webglcanvas');
    const gl = canvas.getContext('webgl');

    // Vertex Shader Source
    const vertexShaderSource = `
        attribute vec3 a_coords;
        attribute vec3 a_color;
        uniform mat4 u_rotX;
        uniform mat4 u_rotY;
        uniform mat4 u_scale;
        varying vec3 v_color;
        void main() {
            gl_Position = u_rotY * u_rotX * u_scale * vec4(a_coords, 1.0);
            v_color = a_color;
        }
    `;

    // Fragment Shader Source
    const fragmentShaderSource = `
        precision mediump float;
        varying vec3 v_color;
        void main() {
            gl_FragColor = vec4(v_color, 1.0);
        }
    `;

    // Compile Shaders and Link Program
    const vsh = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vsh, vertexShaderSource);
    gl.compileShader(vsh);

    const fsh = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fsh, fragmentShaderSource);
    gl.compileShader(fsh);

    const prog = gl.createProgram();
    gl.attachShader(prog, vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    gl.useProgram(prog);

    // Define Hexagon Vertices (Top at z=0.5, Bottom at z=-0.5)
    const vertices = [];
    const colors = [];
    const numSides = 6;
    const radius = 0.5;

    // Generate Top Hexagon (z=0.5)
    for (let i = 0; i < numSides; i++) {
        const angle = (i * 2 * Math.PI) / numSides;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        vertices.push(x, y, 0.5);
        colors.push(1.0, 0.0, 0.0); // Red for top face
    }

    // Generate Bottom Hexagon (z=-0.5)
    for (let i = 0; i < numSides; i++) {
        const angle = (i * 2 * Math.PI) / numSides;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        vertices.push(x, y, -0.5);
        colors.push(0.0, 1.0, 0.0); // Green for bottom face
    }

    // Generate Rectangular Side Faces with Unique Colors
    const sideColors = [
        [0.0, 0.0, 1.0], [1.0, 1.0, 0.0], [1.0, 0.0, 1.0],
        [0.0, 1.0, 1.0], [0.5, 0.5, 0.5], [0.8, 0.2, 0.4]
    ];
    for (let i = 0; i < numSides; i++) {
        const next = (i + 1) % numSides;
        // Add vertices for two triangles per face
        vertices.push(
            ...vertices.slice(i * 3, i * 3 + 3),            // Top current
            ...vertices.slice(next * 3, next * 3 + 3),       // Top next
            ...vertices.slice((i + numSides) * 3, (i + numSides) * 3 + 3), // Bottom current
            ...vertices.slice((next + numSides) * 3, (next + numSides) * 3 + 3) // Bottom next
        );
        // Assign unique color to each face
        colors.push(...sideColors[i], ...sideColors[i], ...sideColors[i], ...sideColors[i]);
    }

    // Buffer Setup
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

    // Index Buffer for Faces (Triangles)
    const indices = [];
    // Top and Bottom Faces (each has 6 triangles)
    for (let i = 0; i < numSides; i++) {
        indices.push(i, (i + 1) % numSides, numSides + i);
    }
    // Side Faces (12 triangles)
    const baseIndex = 2 * numSides; // Offset after top/bottom vertices
    for (let i = 0; i < numSides; i++) {
        const offset = baseIndex + i * 4;
        indices.push(offset, offset + 1, offset + 2, offset + 1, offset + 2, offset + 3);
    }

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    // Attribute Locations
    const a_coords = gl.getAttribLocation(prog, 'a_coords');
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(a_coords, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_coords);

    const a_color = gl.getAttribLocation(prog, 'a_color');
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_color);

    // Uniform Locations
    const u_rotX = gl.getUniformLocation(prog, 'u_rotX');
    const u_rotY = gl.getUniformLocation(prog, 'u_rotY');
    const u_scale = gl.getUniformLocation(prog, 'u_scale');

    // Initial Transformations
    let rotX = 0, rotY = 0, scale = 1.0;

    function updateTransformations() {
        // Rotation Matrices
        const radX = rotX * Math.PI / 180;
        const rotXMat = new Float32Array([
            1, 0, 0, 0,
            0, Math.cos(radX), -Math.sin(radX), 0,
            0, Math.sin(radX), Math.cos(radX), 0,
            0, 0, 0, 1
        ]);

        const radY = rotY * Math.PI / 180;
        const rotYMat = new Float32Array([
            Math.cos(radY), 0, Math.sin(radY), 0,
            0, 1, 0, 0,
            -Math.sin(radY), 0, Math.cos(radY), 0,
            0, 0, 0, 1
        ]);

        // Scale Matrix
        const scaleMat = new Float32Array([
            scale, 0, 0, 0,
            0, scale, 0, 0,
            0, 0, scale, 0,
            0, 0, 0, 1
        ]);

        gl.uniformMatrix4fv(u_rotX, false, rotXMat);
        gl.uniformMatrix4fv(u_rotY, false, rotYMat);
        gl.uniformMatrix4fv(u_scale, false, scaleMat);
    }

    // Key Event Listeners
    document.addEventListener('keydown', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a': rotY -= 5; break;  // Y-axis -
            case 's': rotY += 5; break;  // Y-axis +
            case 'w': rotX -= 5; break;  // X-axis -
            case 'z': rotX += 5; break;  // X-axis +
            case '+': scale *= 1.1; break;
            case '-': scale *= 0.9; break;
        }
        updateTransformations();
        draw();
    });

    // Draw Function
    function draw() {
        gl.clearColor(0.9, 0.9, 0.9, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    }

    // Initial Draw
    updateTransformations();
    draw();
</script>
</body>
</html>